<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°æ®ä¸€è‡´æ€§æµ‹è¯• - Boxing Timer Pro</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a1a, #2d2d30);
            color: white;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        .test-result {
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 12px;
        }
        .pass {
            background: #34C759;
            color: white;
        }
        .fail {
            background: #FF3B30;
            color: white;
        }
        .test-button {
            background: #007AFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin: 10px;
        }
        .test-button:hover {
            background: #0056CC;
        }
        .report {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            white-space: pre-wrap;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        h1, h2 {
            color: #007AFF;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§ª æ•°æ®ä¸€è‡´æ€§å…¨é¢æµ‹è¯•</h1>
        
        <div class="test-section">
            <h2>ğŸ“Š å®æ—¶æµ‹è¯•æ§åˆ¶</h2>
            <button class="test-button" onclick="runFullTest()">ğŸš€ è¿è¡Œå®Œæ•´æµ‹è¯•</button>
            <button class="test-button" onclick="resetAllData()">ğŸ”„ é‡ç½®æ‰€æœ‰æ•°æ®</button>
            <button class="test-button" onclick="viewDetailedReport()">ğŸ“‹ æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Š</button>
        </div>

        <div class="test-section">
            <h2>ğŸ¯ HTMLæ˜¾ç¤ºå€¼æ£€æŸ¥</h2>
            <div id="html-values-test">
                <div class="test-item">
                    <span>Prepareæ—¶é—´æ˜¾ç¤º</span>
                    <span id="prepare-result" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
                <div class="test-item">
                    <span>Roundæ—¶é—´æ˜¾ç¤º</span>
                    <span id="round-result" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
                <div class="test-item">
                    <span>Warningæ—¶é—´æ˜¾ç¤º</span>
                    <span id="warning-result" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
                <div class="test-item">
                    <span>Restæ—¶é—´æ˜¾ç¤º</span>
                    <span id="rest-result" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ’¾ localStorageæ•°æ®æ£€æŸ¥</h2>
            <div id="storage-test">
                <div class="test-item">
                    <span>ç”¨æˆ·é¢„è®¾æ•°æ®</span>
                    <span id="presets-result" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
                <div class="test-item">
                    <span>ä½ç½®è®°å¿†æ•°æ®</span>
                    <span id="positions-result" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ”§ æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥</h2>
            <div id="consistency-test">
                <div class="test-item">
                    <span>Prepareæ•°æ®ä¸€è‡´æ€§</span>
                    <span id="prepare-consistency" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
                <div class="test-item">
                    <span>Roundæ•°æ®ä¸€è‡´æ€§</span>
                    <span id="round-consistency" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
                <div class="test-item">
                    <span>Warningæ•°æ®ä¸€è‡´æ€§</span>
                    <span id="warning-consistency" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
                <div class="test-item">
                    <span>Restæ•°æ®ä¸€è‡´æ€§</span>
                    <span id="rest-consistency" class="test-result">ç­‰å¾…æµ‹è¯•</span>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h2>ğŸ“‹ æµ‹è¯•æŠ¥å‘Š</h2>
            <div class="report" id="test-report">ç‚¹å‡»"è¿è¡Œå®Œæ•´æµ‹è¯•"å¼€å§‹...</div>
        </div>
    </div>

    <!-- å¼•å…¥å¿…è¦çš„æ¨¡å— -->
    <script type="module">
        import { DataConsistency } from './src/utils/DataConsistency.js';
        import { TimePicker } from './src/components/TimePicker.js';

        let dataConsistency;
        let testResults = {};

        // åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
        async function initializeTest() {
            console.log('ğŸ§ª åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ...');
            
            // åˆ›å»ºæµ‹è¯•ç”¨çš„HTMLå…ƒç´ 
            createTestElements();
            
            // åˆå§‹åŒ–æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥å™¨
            dataConsistency = new DataConsistency();
            
            console.log('âœ… æµ‹è¯•ç¯å¢ƒåˆå§‹åŒ–å®Œæˆ');
        }

        // åˆ›å»ºæµ‹è¯•ç”¨çš„HTMLå…ƒç´ 
        function createTestElements() {
            const testContainer = document.createElement('div');
            testContainer.style.display = 'none';
            testContainer.innerHTML = `
                <span id="prepare-time">00:10</span>
                <span id="round-time">00:10</span>
                <span id="warning-time">00:10</span>
                <span id="rest-time">00:30</span>
            `;
            document.body.appendChild(testContainer);
        }

        // è¿è¡Œå®Œæ•´æµ‹è¯•
        window.runFullTest = async function() {
            console.log('ğŸš€ å¼€å§‹å®Œæ•´æ•°æ®ä¸€è‡´æ€§æµ‹è¯•...');
            
            const report = document.getElementById('test-report');
            report.textContent = 'ğŸ”„ æµ‹è¯•è¿›è¡Œä¸­...\n';
            
            await initializeTest();
            
            // 1. æµ‹è¯•HTMLæ˜¾ç¤ºå€¼
            testResults.htmlValues = await testHTMLValues();
            updateResultDisplay('html-values-test', testResults.htmlValues);
            
            // 2. æµ‹è¯•localStorageæ•°æ®
            testResults.storageData = await testStorageData();
            updateResultDisplay('storage-test', testResults.storageData);
            
            // 3. æµ‹è¯•æ•°æ®ä¸€è‡´æ€§
            testResults.consistency = await testDataConsistency();
            updateResultDisplay('consistency-test', testResults.consistency);
            
            // ç”Ÿæˆå®Œæ•´æŠ¥å‘Š
            generateTestReport();
        };

        // æµ‹è¯•HTMLæ˜¾ç¤ºå€¼
        async function testHTMLValues() {
            console.log('ğŸ“„ æµ‹è¯•HTMLæ˜¾ç¤ºå€¼...');
            
            const results = {};
            const phases = ['prepare', 'round', 'warning', 'rest'];
            const expectedValues = { prepare: 10, round: 10, warning: 10, rest: 30 };
            
            phases.forEach(phase => {
                const element = document.getElementById(`${phase}-time`);
                if (element) {
                    const displayText = element.textContent.trim();
                    const seconds = parseTimeText(displayText);
                    const expected = expectedValues[phase];
                    
                    results[phase] = {
                        displayed: displayText,
                        seconds: seconds,
                        expected: expected,
                        pass: seconds === expected
                    };
                } else {
                    results[phase] = {
                        displayed: 'N/A',
                        seconds: 0,
                        expected: expectedValues[phase],
                        pass: false,
                        error: 'Element not found'
                    };
                }
            });
            
            return results;
        }

        // æµ‹è¯•localStorageæ•°æ®
        async function testStorageData() {
            console.log('ğŸ’¾ æµ‹è¯•localStorageæ•°æ®...');
            
            const results = {};
            
            // æµ‹è¯•ç”¨æˆ·é¢„è®¾
            try {
                const presets = localStorage.getItem('boxing-timer-user-presets');
                if (presets) {
                    const parsed = JSON.parse(presets);
                    results.presets = {
                        data: parsed,
                        pass: validatePresetStructure(parsed)
                    };
                } else {
                    results.presets = {
                        data: null,
                        pass: true,
                        note: 'No preset data (using defaults)'
                    };
                }
            } catch (error) {
                results.presets = {
                    error: error.message,
                    pass: false
                };
            }
            
            // æµ‹è¯•ä½ç½®è®°å¿†
            try {
                const positions = localStorage.getItem('boxing-timer-last-selected-indexes');
                if (positions) {
                    const parsed = JSON.parse(positions);
                    results.positions = {
                        data: parsed,
                        pass: validatePositionStructure(parsed)
                    };
                } else {
                    results.positions = {
                        data: null,
                        pass: true,
                        note: 'No position data (using defaults)'
                    };
                }
            } catch (error) {
                results.positions = {
                    error: error.message,
                    pass: false
                };
            }
            
            return results;
        }

        // æµ‹è¯•æ•°æ®ä¸€è‡´æ€§
        async function testDataConsistency() {
            console.log('ğŸ”§ æµ‹è¯•æ•°æ®ä¸€è‡´æ€§...');
            
            const consistencyResult = dataConsistency.checkConsistency();
            const results = {};
            
            const phases = ['prepare', 'round', 'warning', 'rest'];
            phases.forEach(phase => {
                const htmlValue = consistencyResult.htmlValues[phase];
                const presetValue = consistencyResult.userPresets[phase] ? 
                                   consistencyResult.userPresets[phase][0] : null;
                
                results[phase] = {
                    htmlValue: htmlValue,
                    presetValue: presetValue,
                    consistent: htmlValue === presetValue,
                    pass: htmlValue === presetValue
                };
            });
            
            results.overall = {
                hasIssues: consistencyResult.hasIssues,
                issueCount: consistencyResult.issues.length,
                pass: !consistencyResult.hasIssues
            };
            
            return results;
        }

        // æ›´æ–°ç»“æœæ˜¾ç¤º
        function updateResultDisplay(sectionId, results) {
            const section = document.getElementById(sectionId);
            if (!section) return;
            
            const items = section.querySelectorAll('.test-item');
            items.forEach((item, index) => {
                const resultSpan = item.querySelector('.test-result');
                if (resultSpan) {
                    let pass = false;
                    let text = 'UNKNOWN';
                    
                    if (sectionId === 'html-values-test') {
                        const phases = ['prepare', 'round', 'warning', 'rest'];
                        const phase = phases[index];
                        if (results[phase]) {
                            pass = results[phase].pass;
                            text = pass ? 'PASS' : 'FAIL';
                        }
                    } else if (sectionId === 'storage-test') {
                        const keys = ['presets', 'positions'];
                        const key = keys[index];
                        if (results[key]) {
                            pass = results[key].pass;
                            text = pass ? 'PASS' : 'FAIL';
                        }
                    } else if (sectionId === 'consistency-test') {
                        const phases = ['prepare', 'round', 'warning', 'rest'];
                        const phase = phases[index];
                        if (results[phase]) {
                            pass = results[phase].pass;
                            text = pass ? 'PASS' : 'FAIL';
                        }
                    }
                    
                    resultSpan.textContent = text;
                    resultSpan.className = `test-result ${pass ? 'pass' : 'fail'}`;
                }
            });
        }

        // ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
        function generateTestReport() {
            let report = 'ğŸ“Š æ•°æ®ä¸€è‡´æ€§æµ‹è¯•æŠ¥å‘Š\n';
            report += '='.repeat(50) + '\n\n';
            
            // HTMLæ˜¾ç¤ºå€¼æµ‹è¯•ç»“æœ
            report += 'ğŸ“„ HTMLæ˜¾ç¤ºå€¼æµ‹è¯•:\n';
            Object.keys(testResults.htmlValues).forEach(phase => {
                const result = testResults.htmlValues[phase];
                report += `  ${phase}: ${result.displayed} (${result.seconds}s) - ${result.pass ? 'âœ…' : 'âŒ'}\n`;
            });
            report += '\n';
            
            // localStorageæ•°æ®æµ‹è¯•ç»“æœ
            report += 'ğŸ’¾ localStorageæ•°æ®æµ‹è¯•:\n';
            Object.keys(testResults.storageData).forEach(key => {
                const result = testResults.storageData[key];
                report += `  ${key}: ${result.pass ? 'âœ…' : 'âŒ'}\n`;
                if (result.note) report += `    æ³¨: ${result.note}\n`;
                if (result.error) report += `    é”™è¯¯: ${result.error}\n`;
            });
            report += '\n';
            
            // æ•°æ®ä¸€è‡´æ€§æµ‹è¯•ç»“æœ
            report += 'ğŸ”§ æ•°æ®ä¸€è‡´æ€§æµ‹è¯•:\n';
            const phases = ['prepare', 'round', 'warning', 'rest'];
            phases.forEach(phase => {
                const result = testResults.consistency[phase];
                report += `  ${phase}: HTML=${result.htmlValue}s, é¢„è®¾=${result.presetValue}s - ${result.pass ? 'âœ…' : 'âŒ'}\n`;
            });
            
            const overall = testResults.consistency.overall;
            report += `  æ€»ä½“çŠ¶æ€: ${overall.pass ? 'âœ… ä¸€è‡´' : `âŒ å‘ç°${overall.issueCount}ä¸ªé—®é¢˜`}\n\n`;
            
            // æ€»ç»“
            const totalTests = Object.keys(testResults.htmlValues).length + 
                              Object.keys(testResults.storageData).length + 
                              phases.length + 1;
            let passedTests = 0;
            
            Object.values(testResults.htmlValues).forEach(r => r.pass && passedTests++);
            Object.values(testResults.storageData).forEach(r => r.pass && passedTests++);
            phases.forEach(phase => testResults.consistency[phase].pass && passedTests++);
            if (testResults.consistency.overall.pass) passedTests++;
            
            report += `ğŸ“Š æµ‹è¯•æ€»ç»“: ${passedTests}/${totalTests} é€šè¿‡ (${Math.round(passedTests/totalTests*100)}%)\n`;
            
            document.getElementById('test-report').textContent = report;
            console.log('ğŸ“‹ æµ‹è¯•æŠ¥å‘Šå·²ç”Ÿæˆ');
        }

        // é‡ç½®æ‰€æœ‰æ•°æ®
        window.resetAllData = function() {
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ•°æ®å—ï¼Ÿè¿™å°†æ¸…é™¤ç”¨æˆ·é¢„è®¾å’Œä½ç½®è®°å¿†ã€‚')) {
                localStorage.removeItem('boxing-timer-user-presets');
                localStorage.removeItem('boxing-timer-last-selected-indexes');
                alert('âœ… æ‰€æœ‰æ•°æ®å·²é‡ç½®');
                location.reload();
            }
        };

        // æŸ¥çœ‹è¯¦ç»†æŠ¥å‘Š
        window.viewDetailedReport = function() {
            if (dataConsistency) {
                const detailedReport = dataConsistency.generateReport();
                const reportWindow = window.open('', '_blank');
                reportWindow.document.write(`
                    <pre style="font-family: Monaco, monospace; padding: 20px; background: #1a1a1a; color: #fff;">
                        ${detailedReport}
                    </pre>
                `);
            } else {
                alert('è¯·å…ˆè¿è¡Œå®Œæ•´æµ‹è¯•');
            }
        };

        // è¾…åŠ©å‡½æ•°
        function parseTimeText(timeText) {
            const [minutes, seconds] = timeText.split(':').map(s => parseInt(s) || 0);
            return minutes * 60 + seconds;
        }

        function validatePresetStructure(presets) {
            const requiredPhases = ['prepare', 'round', 'warning', 'rest'];
            return requiredPhases.every(phase => 
                presets[phase] && Array.isArray(presets[phase]) && presets[phase].length > 0
            );
        }

        function validatePositionStructure(positions) {
            const requiredPhases = ['prepare', 'round', 'warning', 'rest'];
            return requiredPhases.every(phase => 
                typeof positions[phase] === 'number' && positions[phase] >= 0
            );
        }
    </script>
</body>
</html>